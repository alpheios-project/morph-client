!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var r in n)("object"==typeof exports?exports:e)[r]=n[r]}}(window,function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:r})},n.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=5)}([function(e,t){e.exports='{\n  "engine": {\n    "lat": ["whitakerLat"],\n    "grc": ["morpheusgrc"],\n    "ara": ["aramorph"],\n    "per": ["hazm"]\n  },\n  "url": "https://morph.alpheios.net/api/v1/analysis/word?word=r_WORD&engine=r_ENGINE&lang=r_LANG",\n  "allowUnknownValues": true\n}\n'},function(e,t){e.exports='{\n  "RDF": {\n    "Annotation": {\n      "about": "urn:TuftsMorphologyService:φιλόσοφος:morpheuslat",\n      "creator": {\n        "Agent": {\n          "about": "org.perseus:tools:morpheus.v1"\n        }\n      },\n      "created": {\n        "$": "2017-10-15T14:06:40.522369"\n      },\n      "hasTarget": {\n        "Description": {\n          "about": "urn:word:φιλόσοφος"\n        }\n      },\n      "title": {},\n      "hasBody": {\n        "resource": "urn:uuid:idm140446394225264"\n      },\n      "Body": {\n        "about": "urn:uuid:idm140446394225264",\n        "type": {\n          "resource": "cnt:ContentAsXML"\n        },\n        "rest": {\n          "entry": {\n            "uri": "http://data.perseus.org/collections/urn:cite:perseus:grclexent.lex78378.1",\n            "dict": {\n              "hdwd": {\n                "lang": "grc",\n                "$": "φιλόσοφος"\n              },\n              "pofs": {\n                "order": 3,\n                "$": "noun"\n              },\n              "decl": {\n                "$": "2nd"\n              },\n              "gend": {\n                "$": "masculine"\n              }\n            },\n            "infl": {\n              "term": {\n                "lang": "grc",\n                "stem": {\n                  "$": "φιλοσοφ"\n                },\n                "suff": {\n                  "$": "ος"\n                }\n              },\n              "pofs": {\n                "order": 3,\n                "$": "noun"\n              },\n              "decl": {\n                "$": "2nd"\n              },\n              "case": {\n                "order": 7,\n                "$": "nominative"\n              },\n              "gend": {\n                "$": "masculine"\n              },\n              "num": {\n                "$": "singular"\n              },\n              "stemtype": {\n                "$": "os_ou"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}'},function(e,t){e.exports='{\n  "RDF": {\n    "Annotation": {\n      "about": "urn:TuftsMorphologyService:cepit:whitakerLat",\n      "creator": {\n        "Agent": {\n          "about": "net.alpheios:tools:wordsxml.v1"\n        }\n      },\n      "created": {\n        "$": "2017-08-10T23:16:53.672068"\n      },\n      "hasTarget": {\n        "Description": {\n          "about": "urn:word:cepit"\n        }\n      },\n      "title": {},\n      "hasBody": {\n        "resource": "urn:uuid:idm140578133848416"\n      },\n      "Body": {\n        "about": "urn:uuid:idm140578133848416",\n        "type": {\n          "resource": "cnt:ContentAsXML"\n        },\n        "rest": {\n          "entry": {\n            "infl": {\n              "term": {\n                "lang": "lat",\n                "stem": {\n                  "$": "cep"\n                },\n                "suff": {\n                  "$": "it"\n                }\n              },\n              "pofs": {\n                "order": 3,\n                "$": "verb"\n              },\n              "conj": {\n                "$": "3rd"\n              },\n              "var": {\n                "$": "1st"\n              },\n              "tense": {\n                "$": "perfect"\n              },\n              "voice": {\n                "$": "active"\n              },\n              "mood": {\n                "$": "indicative"\n              },\n              "pers": {\n                "$": "3rd"\n              },\n              "num": {\n                "$": "singular"\n              }\n            },\n            "dict": {\n              "hdwd": {\n                "lang": "lat",\n                "$": "capio, capere, cepi, captus"\n              },\n              "pofs": {\n                "order": 3,\n                "$": "verb"\n              },\n              "conj": {\n                "$": "3rd"\n              },\n              "kind": {\n                "$": "transitive"\n              },\n              "freq": {\n                "order": 6,\n                "$": "very frequent"\n              },\n              "src": {\n                "$": "Ox.Lat.Dict."\n              }\n            },\n            "mean": {\n              "$": "take hold, seize; grasp; take bribe; arrest/capture; put on; occupy; captivate;"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n'},function(e,t){e.exports='{\n  "RDF": {\n    "Annotation": {\n      "about": "urn:TuftsMorphologyService:mare:morpheuslat",\n      "creator": {\n        "Agent": {\n          "about": "org.perseus:tools:morpheus.v1"\n        }\n      },\n      "created": {\n        "$": "2017-09-08T06:59:48.639180"\n      },\n      "rights": {\n        "$": "Morphology provided by Morpheus from the Perseus Digital Library at Tufts University."\n      },\n      "hasTarget": {\n        "Description": {\n          "about": "urn:word:mare"\n        }\n      },\n      "title": {},\n      "hasBody": [\n        {\n          "resource": "urn:uuid:idm140446402389888"\n        },\n        {\n          "resource": "urn:uuid:idm140446402332400"\n        },\n        {\n          "resource": "urn:uuid:idm140446402303648"\n        }\n      ],\n      "Body": [\n        {\n          "about": "urn:uuid:idm140446402389888",\n          "type": {\n            "resource": "cnt:ContentAsXML"\n          },\n          "rest": {\n            "entry": {\n              "uri": "http://data.perseus.org/collections/urn:cite:perseus:latlexent.lex34070.1",\n              "dict": {\n                "hdwd": {\n                  "lang": "lat",\n                  "$": "mare"\n                },\n                "pofs": {\n                  "order": 3,\n                  "$": "noun"\n                },\n                "decl": {\n                  "$": "3rd"\n                },\n                "gend": {\n                  "$": "neuter"\n                }\n              },\n              "infl": [\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "mar"\n                    },\n                    "suff": {\n                      "$": "e"\n                    }\n                  },\n                  "pofs": {\n                    "order": 3,\n                    "$": "noun"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "case": {\n                    "order": 3,\n                    "$": "ablative"\n                  },\n                  "gend": {\n                    "$": "neuter"\n                  },\n                  "num": {\n                    "$": "singular"\n                  },\n                  "stemtype": {\n                    "$": "is_is"\n                  }\n                },\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "mar"\n                    },\n                    "suff": {\n                      "$": "e"\n                    }\n                  },\n                  "pofs": {\n                    "order": 3,\n                    "$": "noun"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "case": {\n                    "order": 7,\n                    "$": "nominative"\n                  },\n                  "gend": {\n                    "$": "neuter"\n                  },\n                  "num": {\n                    "$": "singular"\n                  },\n                  "stemtype": {\n                    "$": "is_is"\n                  }\n                },\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "mar"\n                    },\n                    "suff": {\n                      "$": "e"\n                    }\n                  },\n                  "pofs": {\n                    "order": 3,\n                    "$": "noun"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "case": {\n                    "order": 1,\n                    "$": "vocative"\n                  },\n                  "gend": {\n                    "$": "neuter"\n                  },\n                  "num": {\n                    "$": "singular"\n                  },\n                  "stemtype": {\n                    "$": "is_is"\n                  }\n                },\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "mar"\n                    },\n                    "suff": {\n                      "$": "e"\n                    }\n                  },\n                  "pofs": {\n                    "order": 3,\n                    "$": "noun"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "case": {\n                    "order": 4,\n                    "$": "accusative"\n                  },\n                  "gend": {\n                    "$": "neuter"\n                  },\n                  "num": {\n                    "$": "singular"\n                  },\n                  "stemtype": {\n                    "$": "is_is"\n                  }\n                }\n              ],\n              "mean": {\n                "$": "the sea"\n              }\n            }\n          }\n        },\n        {\n          "about": "urn:uuid:idm140446402332400",\n          "type": {\n            "resource": "cnt:ContentAsXML"\n          },\n          "rest": {\n            "entry": {\n              "uri": "http://data.perseus.org/collections/urn:cite:perseus:latlexent.lex34118.1",\n              "dict": {\n                "hdwd": {\n                  "lang": "lat",\n                  "$": "marum"\n                },\n                "pofs": {\n                  "order": 3,\n                  "$": "noun"\n                },\n                "decl": {\n                  "$": "2nd"\n                },\n                "gend": {\n                  "$": "neuter"\n                }\n              },\n              "infl": {\n                "term": {\n                  "lang": "lat",\n                  "stem": {\n                    "$": "mar"\n                  },\n                  "suff": {\n                    "$": "e"\n                  }\n                },\n                "pofs": {\n                  "order": 3,\n                  "$": "noun"\n                },\n                "decl": {\n                  "$": "2nd"\n                },\n                "case": {\n                  "order": 1,\n                  "$": "vocative"\n                },\n                "gend": {\n                  "$": "neuter"\n                },\n                "num": {\n                  "$": "singular"\n                },\n                "stemtype": {\n                  "$": "us_i"\n                }\n              }\n            }\n          }\n        },\n        {\n          "about": "urn:uuid:idm140446402303648",\n          "type": {\n            "resource": "cnt:ContentAsXML"\n          },\n          "rest": {\n            "entry": {\n              "uri": "http://data.perseus.org/collections/urn:cite:perseus:latlexent.lex34119.1",\n              "dict": {\n                "hdwd": {\n                  "lang": "lat",\n                  "$": "mas"\n                },\n                "pofs": {\n                  "order": 2,\n                  "$": "adjective"\n                },\n                "decl": {\n                  "$": "3rd"\n                }\n              },\n              "infl": [\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "mare"\n                    }\n                  },\n                  "pofs": {\n                    "order": 2,\n                    "$": "adjective"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "case": {\n                    "order": 3,\n                    "$": "ablative"\n                  },\n                  "gend": {\n                    "$": "masculine"\n                  },\n                  "num": {\n                    "$": "singular"\n                  },\n                  "stemtype": {\n                    "$": "irreg_adj3"\n                  },\n                  "morph": {\n                    "$": "indeclform"\n                  }\n                },\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "mare"\n                    }\n                  },\n                  "pofs": {\n                    "order": 2,\n                    "$": "adjective"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "case": {\n                    "order": 3,\n                    "$": "ablative"\n                  },\n                  "gend": {\n                    "$": "feminine"\n                  },\n                  "num": {\n                    "$": "singular"\n                  },\n                  "stemtype": {\n                    "$": "irreg_adj3"\n                  },\n                  "morph": {\n                    "$": "indeclform"\n                  }\n                },\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "mare"\n                    }\n                  },\n                  "pofs": {\n                    "order": 2,\n                    "$": "adjective"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "case": {\n                    "order": 3,\n                    "$": "ablative"\n                  },\n                  "gend": {\n                    "$": "neuter"\n                  },\n                  "num": {\n                    "$": "singular"\n                  },\n                  "stemtype": {\n                    "$": "irreg_adj3"\n                  },\n                  "morph": {\n                    "$": "indeclform"\n                  }\n                }\n              ]\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n'},function(e,t){e.exports='{\n  "RDF": {\n    "Annotation": {\n      "about": "urn:TuftsMorphologyService:cupidinibus:whitakerLat",\n      "creator": {\n        "Agent": {\n          "about": "net.alpheios:tools:wordsxml.v1"\n        }\n      },\n      "created": {\n        "$": "2017-08-10T23:15:29.185581"\n      },\n      "hasTarget": {\n        "Description": {\n          "about": "urn:word:cupidinibus"\n        }\n      },\n      "title": {},\n      "hasBody": [\n        {\n          "resource": "urn:uuid:idm140578094883136"\n        },\n        {\n          "resource": "urn:uuid:idm140578158026160"\n        }\n      ],\n      "Body": [\n        {\n          "about": "urn:uuid:idm140578094883136",\n          "type": {\n            "resource": "cnt:ContentAsXML"\n          },\n          "rest": {\n            "entry": {\n              "infl": [\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "cupidin"\n                    },\n                    "suff": {\n                      "$": "ibus"\n                    }\n                  },\n                  "pofs": {\n                    "order": 5,\n                    "$": "noun"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "var": {\n                    "$": "1st"\n                  },\n                  "case": {\n                    "order": 2,\n                    "$": "locative"\n                  },\n                  "num": {\n                    "$": "plural"\n                  },\n                  "gend": {\n                    "$": "masculine"\n                  }\n                },\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "cupidin"\n                    },\n                    "suff": {\n                      "$": "ibus"\n                    }\n                  },\n                  "pofs": {\n                    "order": 5,\n                    "$": "noun"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "var": {\n                    "$": "1st"\n                  },\n                  "case": {\n                    "order": 5,\n                    "$": "dative"\n                  },\n                  "num": {\n                    "$": "plural"\n                  },\n                  "gend": {\n                    "$": "masculine"\n                  }\n                },\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "cupidin"\n                    },\n                    "suff": {\n                      "$": "ibus"\n                    }\n                  },\n                  "pofs": {\n                    "order": 5,\n                    "$": "noun"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "var": {\n                    "$": "1st"\n                  },\n                  "case": {\n                    "order": 3,\n                    "$": "ablative"\n                  },\n                  "num": {\n                    "$": "plural"\n                  },\n                  "gend": {\n                    "$": "masculine"\n                  }\n                }\n              ],\n              "dict": {\n                "hdwd": {\n                  "lang": "lat",\n                  "$": "Cupido, Cupidinis"\n                },\n                "pofs": {\n                  "order": 5,\n                  "$": "noun"\n                },\n                "decl": {\n                  "$": "3rd"\n                },\n                "gend": {\n                  "$": "masculine"\n                },\n                "area": {\n                  "$": "religion"\n                },\n                "freq": {\n                  "order": 4,\n                  "$": "common"\n                },\n                "src": {\n                  "$": "Ox.Lat.Dict."\n                }\n              },\n              "mean": {\n                "$": "Cupid, son of Venus; personification of carnal desire;"\n              }\n            }\n          }\n        },\n        {\n          "about": "urn:uuid:idm140578158026160",\n          "type": {\n            "resource": "cnt:ContentAsXML"\n          },\n          "rest": {\n            "entry": {\n              "infl": [\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "cupidin"\n                    },\n                    "suff": {\n                      "$": "ibus"\n                    }\n                  },\n                  "pofs": {\n                    "order": 5,\n                    "$": "noun"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "var": {\n                    "$": "1st"\n                  },\n                  "case": {\n                    "order": 2,\n                    "$": "locative"\n                  },\n                  "num": {\n                    "$": "plural"\n                  },\n                  "gend": {\n                    "$": "common"\n                  }\n                },\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "cupidin"\n                    },\n                    "suff": {\n                      "$": "ibus"\n                    }\n                  },\n                  "pofs": {\n                    "order": 5,\n                    "$": "noun"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "var": {\n                    "$": "1st"\n                  },\n                  "case": {\n                    "order": 5,\n                    "$": "dative"\n                  },\n                  "num": {\n                    "$": "plural"\n                  },\n                  "gend": {\n                    "$": "common"\n                  }\n                },\n                {\n                  "term": {\n                    "lang": "lat",\n                    "stem": {\n                      "$": "cupidin"\n                    },\n                    "suff": {\n                      "$": "ibus"\n                    }\n                  },\n                  "pofs": {\n                    "order": 5,\n                    "$": "noun"\n                  },\n                  "decl": {\n                    "$": "3rd"\n                  },\n                  "var": {\n                    "$": "1st"\n                  },\n                  "case": {\n                    "order": 3,\n                    "$": "ablative"\n                  },\n                  "num": {\n                    "$": "plural"\n                  },\n                  "gend": {\n                    "$": "common"\n                  }\n                }\n              ],\n              "dict": {\n                "hdwd": {\n                  "lang": "lat",\n                  "$": "cupido, cupidinis"\n                },\n                "pofs": {\n                  "order": 5,\n                  "$": "noun"\n                },\n                "decl": {\n                  "$": "3rd"\n                },\n                "gend": {\n                  "$": "common"\n                },\n                "freq": {\n                  "order": 5,\n                  "$": "frequent"\n                },\n                "src": {\n                  "$": "Ox.Lat.Dict."\n                }\n              },\n              "mean": {\n                "$": "desire/love/wish/longing (passionate); lust; greed, appetite; desire for gain;"\n              }\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n'},function(e,t,n){"use strict";n.r(t);var r=class{prepareRequestUrl(e,t){return null}async getHomonym(e,t){}fetch(e,t){let n=this.prepareRequestUrl(e,t);return new Promise((t,r)=>{n?window.fetch(n).then(function(e){try{if(e.ok){let n=e.json();t(n)}else r(e.statusText)}catch(e){r(e)}}).catch(e=>{r(e)}):r(new Error(`Unable to prepare parser request url for ${e}`))})}fetchTestData(e,t){return new Promise((e,t)=>{try{e({})}catch(e){t(e)}})}transform(e,t){return{}}};const a=Symbol("word"),s=Symbol("char"),o=Symbol("ltr"),i=Symbol("rtl"),u=Symbol("undefined"),l=Symbol("latin"),c=Symbol("greek"),g=Symbol("arabic"),d=Symbol("persian"),p="undefined",h="lat",f="la",m="grc",E="ara",y="ar",I="fas",A="per",w="fa-IR",v="fa",_="adjective",S="adverb",C="adverbial",D="article",O="conjunction",T="exclamation",F="interjection",L="noun",V="numeral",$="particle",N="prefix",b="preposition",R="pronoun",P="suffix",U="supine",M="verb",x="verb participle",j="masculine",k="feminine",B="neuter",G="ablative",W="accusative",q="dative",z="genitive",K="locative",X="nominative",H="vocative",J="gerundive",Q="imperative",Y="indicative",Z="infinitive",ee="optative",te="participle",ne="subjunctive",re="supine",ae="singular",se="plural",oe="dual",ie="1st",ue="2nd",le="3rd",ce="4th",ge="5th",de="aorist",pe="future",he="future perfect",fe="imperfect",me="perfect",Ee="pluperfect",ye="present",Ie="active",Ae="passive",we="mediopassive",ve="middle",_e="irregular",Se="regular",Ce="personal",De="reflexive",Oe="possessive",Te="demonstrative",Fe="relative",Le="interrogative",Ve="general relative",$e="indefinite",Ne="intensive",be="reciprocal";var Re=Object.freeze({LANG_UNIT_WORD:a,LANG_UNIT_CHAR:s,LANG_DIR_LTR:o,LANG_DIR_RTL:i,LANG_UNDEFINED:u,LANG_LATIN:l,LANG_GREEK:c,LANG_ARABIC:g,LANG_PERSIAN:d,STR_LANG_CODE_UNDEFINED:p,STR_LANG_CODE_LAT:h,STR_LANG_CODE_LA:f,STR_LANG_CODE_GRC:m,STR_LANG_CODE_ARA:E,STR_LANG_CODE_AR:y,STR_LANG_CODE_FAS:I,STR_LANG_CODE_PER:A,STR_LANG_CODE_FA_IR:w,STR_LANG_CODE_FA:v,POFS_ADJECTIVE:_,POFS_ADVERB:S,POFS_ADVERBIAL:C,POFS_ARTICLE:D,POFS_CONJUNCTION:O,POFS_EXCLAMATION:T,POFS_INTERJECTION:F,POFS_NOUN:L,POFS_NUMERAL:V,POFS_PARTICLE:$,POFS_PREFIX:N,POFS_PREPOSITION:b,POFS_PRONOUN:R,POFS_SUFFIX:P,POFS_SUPINE:U,POFS_VERB:M,POFS_VERB_PARTICIPLE:x,GEND_MASCULINE:j,GEND_FEMININE:k,GEND_NEUTER:B,GEND_COMMON:"common",GEND_ANIMATE:"animate",GEND_INANIMATE:"inanimate",GEND_PERSONAL_MASCULINE:"personal masculine",GEND_ANIMATE_MASCULINE:"animate masculine",GEND_INANIMATE_MASCULINE:"inanimate masculine",COMP_POSITIVE:"positive",COMP_COMPARITIVE:"comparative",COMP_SUPERLATIVE:"superlative",CASE_ABESSIVE:"abessive",CASE_ABLATIVE:G,CASE_ABSOLUTIVE:"absolutive",CASE_ACCUSATIVE:W,CASE_ADDIRECTIVE:"addirective",CASE_ADELATIVE:"adelative",CASE_ADESSIVE:"adessive",CASE_ADVERBIAL:"adverbial",CASE_ALLATIVE:"allative",CASE_ANTESSIVE:"antessive",CASE_APUDESSIVE:"apudessive",CASE_AVERSIVE:"aversive",CASE_BENEFACTIVE:"benefactive",CASE_CARITIVE:"caritive",CASE_CAUSAL:"causal",CASE_CAUSAL_FINAL:"causal-final",CASE_COMITATIVE:"comitative",CASE_DATIVE:q,CASE_DELATIVE:"delative",CASE_DIRECT:"direct",CASE_DISTRIBUTIVE:"distributive",CASE_DISTRIBUTIVE_TEMPORAL:"distributive-temporal",CASE_ELATIVE:"elative",CASE_ERGATIVE:"ergative",CASE_ESSIVE:"essive",CASE_ESSIVE_FORMAL:"essive-formal",CASE_ESSIVE_MODAL:"essive-modal",CASE_EQUATIVE:"equative",CASE_EVITATIVE:"evitative",CASE_EXESSIVE:"exessive",CASE_FINAL:"final",CASE_FORMAL:"formal",CASE_GENITIVE:z,CASE_ILLATIVE:"illative",CASE_INELATIVE:"inelative",CASE_INESSIVE:"inessive",CASE_INSTRUCTIVE:"instructive",CASE_INSTRUMENTAL:"instrumental",CASE_INSTRUMENTAL_COMITATIVE:"instrumental-comitative",CASE_INTRANSITIVE:"intransitive",CASE_LATIVE:"lative",CASE_LOCATIVE:K,CASE_MODAL:"modal",CASE_MULTIPLICATIVE:"multiplicative",CASE_NOMINATIVE:X,CASE_PARTITIVE:"partitive",CASE_PEGATIVE:"pegative",CASE_PERLATIVE:"perlative",CASE_POSSESSIVE:"possessive",CASE_POSTELATIVE:"postelative",CASE_POSTDIRECTIVE:"postdirective",CASE_POSTESSIVE:"postessive",CASE_POSTPOSITIONAL:"postpositional",CASE_PREPOSITIONAL:"prepositional",CASE_PRIVATIVE:"privative",CASE_PROLATIVE:"prolative",CASE_PROSECUTIVE:"prosecutive",CASE_PROXIMATIVE:"proximative",CASE_SEPARATIVE:"separative",CASE_SOCIATIVE:"sociative",CASE_SUBDIRECTIVE:"subdirective",CASE_SUBESSIVE:"subessive",CASE_SUBELATIVE:"subelative",CASE_SUBLATIVE:"sublative",CASE_SUPERDIRECTIVE:"superdirective",CASE_SUPERESSIVE:"superessive",CASE_SUPERLATIVE:"superlative",CASE_SUPPRESSIVE:"suppressive",CASE_TEMPORAL:"temporal",CASE_TERMINATIVE:"terminative",CASE_TRANSLATIVE:"translative",CASE_VIALIS:"vialis",CASE_VOCATIVE:H,MOOD_ADMIRATIVE:"admirative",MOOD_COHORTATIVE:"cohortative",MOOD_CONDITIONAL:"conditional",MOOD_DECLARATIVE:"declarative",MOOD_DUBITATIVE:"dubitative",MOOD_ENERGETIC:"energetic",MOOD_EVENTIVE:"eventive",MOOD_GENERIC:"generic",MOOD_GERUNDIVE:J,MOOD_HYPOTHETICAL:"hypothetical",MOOD_IMPERATIVE:Q,MOOD_INDICATIVE:Y,MOOD_INFERENTIAL:"inferential",MOOD_INFINITIVE:Z,MOOD_INTERROGATIVE:"interrogative",MOOD_JUSSIVE:"jussive",MOOD_NEGATIVE:"negative",MOOD_OPTATIVE:ee,MOOD_PARTICIPLE:te,MOOD_PRESUMPTIVE:"presumptive",MOOD_RENARRATIVE:"renarrative",MOOD_SUBJUNCTIVE:ne,MOOD_SUPINE:re,NUM_SINGULAR:ae,NUM_PLURAL:se,NUM_DUAL:oe,NUM_TRIAL:"trial",NUM_PAUCAL:"paucal",NUM_SINGULATIVE:"singulative",NUM_COLLECTIVE:"collective",NUM_DISTRIBUTIVE_PLURAL:"distributive plural",NRL_CARDINAL:"cardinal",NRL_ORDINAL:"ordinal",NRL_DISTRIBUTIVE:"distributive",NURL_NUMERAL_ADVERB:"numeral adverb",ORD_1ST:ie,ORD_2ND:ue,ORD_3RD:le,ORD_4TH:ce,ORD_5TH:ge,ORD_6TH:"6th",ORD_7TH:"7th",ORD_8TH:"8th",ORD_9TH:"9th",TENSE_AORIST:de,TENSE_FUTURE:pe,TENSE_FUTURE_PERFECT:he,TENSE_IMPERFECT:fe,TENSE_PAST_ABSOLUTE:"past absolute",TENSE_PERFECT:me,TENSE_PLUPERFECT:Ee,TENSE_PRESENT:ye,VKIND_TO_BE:"to be",VKIND_COMPOUNDS_OF_TO_BE:"compounds of to be",VKIND_TAKING_ABLATIVE:"taking ablative",VKIND_TAKING_DATIVE:"taking dative",VKIND_TAKING_GENITIVE:"taking genitive",VKIND_TRANSITIVE:"transitive",VKIND_INTRANSITIVE:"intransitive",VKIND_IMPERSONAL:"impersonal",VKIND_DEPONENT:"deponent",VKIND_SEMIDEPONENT:"semideponent",VKIND_PERFECT_DEFINITE:"perfect definite",VOICE_ACTIVE:Ie,VOICE_PASSIVE:Ae,VOICE_MEDIOPASSIVE:we,VOICE_IMPERSONAL_PASSIVE:"impersonal passive",VOICE_MIDDLE:ve,VOICE_ANTIPASSIVE:"antipassive",VOICE_REFLEXIVE:"reflexive",VOICE_RECIPROCAL:"reciprocal",VOICE_CAUSATIVE:"causative",VOICE_ADJUTATIVE:"adjutative",VOICE_APPLICATIVE:"applicative",VOICE_CIRCUMSTANTIAL:"circumstantial",VOICE_DEPONENT:"deponent",TYPE_IRREGULAR:_e,TYPE_REGULAR:Se,CLASS_PERSONAL:Ce,CLASS_REFLEXIVE:De,CLASS_POSSESSIVE:Oe,CLASS_DEMONSTRATIVE:Te,CLASS_RELATIVE:Fe,CLASS_INTERROGATIVE:Le,CLASS_GENERAL_RELATIVE:Ve,CLASS_INDEFINITE:$e,CLASS_INTENSIVE:Ne,CLASS_RECIPROCAL:be});class Pe{constructor(e,t,n,r){this.text=e,this.language=t,this.format=n,this.lemmaText=r}static readObject(e){return new Pe(e.text,e.language,e.format,e.lemmaText)}}class Ue{constructor(e,t){this.lemmaWord=e,this.languageID=t,this.shortDefs=[],this.fullDefs=[]}static readObject(e){let t=new Ue(e.lemmaWord,e.languageID);for(let n of e.shortDefs)t.shortDefs.push(Pe.readObject(n));for(let n of e.fullDefs)t.fullDefs.push(Pe.readObject(n));return t}isEmpty(){return 0===this.shortDefs.length&&0===this.fullDefs.length}appendShortDefs(e){return e&&(Array.isArray(e)||(e=[e]),this.shortDefs=this.shortDefs.concat(e)),this.shortDefs}clearShortDefs(){this.shortDefs=[]}appendFullDefs(e){return e&&(Array.isArray(e)||(e=[e]),this.fullDefs=this.fullDefs.concat(e)),this.fullDefs}clearFullDefs(){this.fullDefs=[]}}class Me{constructor(e=[],t=!1){this.hash={};for(let t of e)this.map(t,t);return this.returnUnknown=t,this}map(e,t){if(!e)throw new Error("Imported value should not be empty.");if(!t)throw new Error("Library value should not be empty.");return this.hash[e]=t,this}has(e){return this.hash.hasOwnProperty(e)}get(e){if(this.has(e))return this.hash[e];if(this.returnUnknown)return e;throw new Error('A value "'+e+'" is not found in the importer.')}}class xe{constructor(e,t,n){if(!t||!Array.isArray(t))throw new Error("Values should be an array (or an empty array) of values.");if(!n)throw new Error("FeatureType constructor requires a language");this.type=e,this.languageID=void 0,this.languageCode=void 0,({languageID:this.languageID,languageCode:this.languageCode}=nt.getLanguageAttrs(n)),this._orderIndex=[],this._orderLookup={};for(const[e,n]of t.entries())if(this._orderIndex.push(n),Array.isArray(n))for(let t of n)this[t]=new at(this.type,t,this.languageID),this._orderLookup[t]=e;else this[n]=new at(this.type,n,this.languageID),this._orderLookup[n]=e}get language(){return console.warn('Please use a "languageID" instead of a "language"'),this.languageCode}hasUnrestrictedValue(){return 1===this.orderedValues.length&&this.orderedValues[0]===xe.UNRESTRICTED_VALUE}get(e,t=1){if(e)return new at(this.type,[[e,t]],this.languageID);throw new Error("A non-empty value should be provided.")}getValues(e){return new at(this.type,e,this.languageID)}getFromImporter(e,t){let n;try{n=this.importer[e].get(t)}catch(e){n=this.get(t)}return n}addImporter(e){if(!e)throw new Error("Importer should have a non-empty name.");return this.importer=this.importer||{},this.importer[e]=this.importer[e]||new Me,this.importer[e]}get orderedFeatures(){return this.orderedValues.map(e=>new at(this.type,e,this.languageID))}get orderedValues(){return this._orderIndex}get orderLookup(){return this._orderLookup}set order(e){if(!e||Array.isArray(e)&&0===e.length)throw new Error("A non-empty list of values should be provided.");Array.isArray(e)||(e=[e]);for(let t of e)if(Array.isArray(t))for(let e of t){if(!this.hasOwnProperty(e.value))throw new Error('Trying to order an element with "'+e.value+'" value that is not stored in a "'+this.type+'" type.');if(e.type!==this.type)throw new Error('Trying to order an element with type "'+e.type+'" that is different from "'+this.type+'".');if(!nt.compareLanguages(e.languageID,this.languageID))throw new Error(`Trying to order an element with language "${e.languageID.toString()}" that is different from "${this.languageID.toString()}"`)}else{if(!this.hasOwnProperty(t.value))throw new Error('Trying to order an element with "'+t.value+'" value that is not stored in a "'+this.type+'" type.');if(t.type!==this.type)throw new Error('Trying to order an element with type "'+t.type+'" that is different from "'+this.type+'".');if(!nt.compareLanguages(t.languageID,this.languageID))throw new Error(`Trying to order an element with language "${t.languageID.toString()}" that is different from "${this.languageID.toString()}"`)}this._orderLookup={},this._orderIndex=[];for(const[t,n]of e.entries())if(Array.isArray(n)){let e=[];for(const r of n)this._orderLookup[r.value]=t,e.push(r.value);this._orderIndex[t]=e}else this._orderLookup[n.value]=t,this._orderIndex[t]=n.value}}xe.UNRESTRICTED_VALUE=Symbol("unrestricted");class je{constructor(e,t,n={}){for(let n of t)this[n]=e[n];Object.assign(this,n)}hasFeatureValue(e,t){return!!this.hasOwnProperty(e)&&this[e].values.includes(t)}toString(){let e=[];for(let t of Object.getOwnPropertyNames(this).sort()){let n=this[t]instanceof at?this[t].values.sort().join(","):this[t];e.push(n)}return e.join(" ")}}class ke{constructor(e,t=[],n=null){this.groupingKey=e,this.inflections=t}append(e){this.inflections.push(e)}}class Be{constructor(){this.context_backward=Be.contextBackward}static get contextForward(){return 0}static get contextBackward(){return 0}static get direction(){return o}static get baseUnit(){return a}get contextForward(){return console.warn('Please use static "contextForward" instead'),this.constructor.contextForward}get contextBackward(){return console.warn('Please use static "contextBackward" instead'),this.constructor.contextBackward}get direction(){return console.warn('Please use static "direction" instead'),this.constructor.direction}get baseUnit(){return console.warn('Please use static "baseUnit" instead'),this.constructor.baseUnit}get features(){return console.warn('Please use individual "getFeatureType" or static "features" instead'),this.constructor.features}static get featureNames(){return this.featureValues.keys()}static typeFeature(e){if(this.typeFeatures.has(e))return this.typeFeatures.get(e);throw new Error(`Type feature "${e}" is not defined within "${this}"`)}static get typeFeatures(){console.warn("This getter must be defined in a descendant class")}static get features(){let e={};for(const t of this.featureNames)e[t]=this.getFeature(t);return e}static get languageID(){return u}static get languageCode(){return p}static get languageCodes(){return[]}static get codes(){return console.warn('Use static "languageCodes" instead'),this.languageCodes}get codes(){return console.warn('Please use a static version of "codes" instead'),this.constructor.languageCodes}toCode(){return console.warn('Please use a static "languageCode" instead'),this.constructor.languageCode}static toCode(){return console.warn('Please use a static "languageCode" instead'),this.languageCode}static get featureValues(){return new Map([[at.types.part,[S,C,_,D,O,T,F,L,V,$,N,b,R,P,U,M,x]],[at.types.gender,[j,k,B]],[at.types.type,[Se,_e]],[at.types.person,[ie,ue,le]],[at.types.age,[]],[at.types.area,[]],[at.types.source,[]],[at.types.frequency,[]],[at.types.geo,[]],[at.types.pronunciation,[]],[at.types.kind,[]],[at.types.comparison,[]],[at.types.morph,[]],[at.types.stemtype,[]],[at.types.derivtype,[]]])}static get sourceLanguage(){return console.warn("Please use languageID directly"),this.languageID}get sourceLanguage(){return console.warn("Please use languageID directly"),this.constructor.languageID}static getFeatureType(e){console.warn("Please use getFeature instead");let t=this.featureValues;if(t.has(e))return new xe(e,t.get(e),this.languageID);throw new Error(`Feature "${e}" is not defined`)}static getFeature(e){let t=this.featureValues;if(t.has(e)){let n=t.get(e);return new at(e,n,this.languageID,1,n)}throw new Error(`Feature "${e}" is not defined`)}_initializeFeatures(){let e={};for(const t of this.constructor.featureValues.keys())e[t]=this.constructor.getFeature(t);return e}grammarFeatures(){return console.warn('Please use a static version of "grammarFeatures" instead'),this.constructor.grammarFeatures()}static grammarFeatures(){return[]}static canInflect(e){return!1}static supportsLanguage(e){return this.languageCodes.includes[e]}static normalizeWord(e){return e}static alternateWordEncodings(e,t=null,n=null,r=null){return[]}alternateWordEncodings(e,t,n,r){return console.warn('Please use static "alternateWordEncodings" instead'),this.constructor.alternateWordEncodings(e,t,n,r)}static getPunctuation(){return".,;:!?'\"(){}\\[\\]<>/\\ ‐‑‒–—―‘’“”··\n\r"}getPunctuation(){return console.warn('Please use a static version of "getPunctuation"'),this.constructor.getPunctuation()}toString(){return String(this.constructor.languageCode)}isEqual(e){return nt.compareLanguages(this.languageID,e.languageID)}static hasCode(e){if(this.isLanguageCode(e))return this.languageCodes.includes(e);throw new Error(`Format of a "${e}" is incorrect`)}static isLanguageID(e){return"symbol"==typeof e}static isLanguageCode(e){return!Be.isLanguageID(e)}canInflect(e){return console.warn('Please use a static version of "canInflect" instead'),this.constructor.canInflect(e)}static groupInflectionsForDisplay(e){let t=new Map;for(let n of e){let e=new je(n,[at.types.part,at.types.declension,at.types.dialect,at.types.comparison],{prefix:n.prefix,suffix:n.suffix,stem:n.stem}),r=e.toString();t.has(r)?t.get(r).append(n):t.set(r,new ke(e,[n]))}for(let e of t){let t=new Map;for(let n of e[1].inflections){let e,r=!1;n[at.types.grmCase]?(e=at.types.number,r=!0):e=n[at.types.tense]?at.types.tense:n[at.types.part]===M?at.types.part:n[at.types.part]===S?at.types.part:"misc";let a=new je(n,[e],{isCaseInflectionSet:r}),s=a.toString();t.has(s)?t.get(s).append(n):t.set(s,new ke(a,[n]))}for(let e of t){let t=new Map,n=new Map;for(let r of e[1].inflections){let e=r[at.types.grmCase]?Math.max(r[at.types.grmCase].items.map(e=>e.sortOrder)):1,a=new je(r,[at.types.tense,at.types.voice]),s=a.toString();t.has(s)?t.get(s).append(r):(t.set(s,new ke(a,[r],e)),n.set(s,e))}e[1].inflections=[];let r=Array.from(t.keys()).sort((e,t)=>{let r=n.get(e),a=n.get(t);return r>a?-1:a>r?1:0});for(let n of r)e[1].inflections.push(t.get(n))}for(let e of t){let t=e[1];for(let e of t.inflections){let t=new Map;for(let n of e.inflections){let e=new je(n,[at.types.grmCase,at.types.comparison,at.types.gender,at.types.number,at.types.person,at.types.tense,at.types.mood,at.types.voice]),r=e.toString();t.has(r)?t.get(r).append(n):t.set(r,new ke(e,[n]))}e.inflections=Array.from(t.values())}}e[1].inflections=Array.from(t.values())}return Array.from(t.values())}groupInflectionsForDisplay(e){return console.warn('Please use a static version of "groupInflectionsForDisplay" instead'),this.constructor.groupInflectionsForDisplay(e)}}let Ge=new Map,We=!1;class qe extends Be{static get languageID(){return l}static get languageCode(){return h}static get languageCodes(){return[f,h]}static get contextForward(){return 0}static get contextBackward(){return 0}static get direction(){return o}static get baseUnit(){return a}static get featureValues(){return new Map([...Be.featureValues,[at.types.grmClass,[Ce,De,Oe,Te,Fe,Le]],[at.types.number,[ae,se]],[at.types.grmCase,[X,z,q,W,G,K,H]],[at.types.declension,[ie,ue,le,ce,ge]],[at.types.tense,[ye,fe,pe,me,Ee,he]],[at.types.voice,[Ie,Ae]],[at.types.mood,[Y,ne,Q,te,re,J,te,Z]],[at.types.conjugation,[ie,ue,le,ce]]])}static get typeFeatures(){return We||this.initTypeFeatures(),Ge}static initTypeFeatures(){for(const e of this.featureNames)Ge.set(e,this.getFeature(e));We=!0}static grammarFeatures(){return[at.types.part,at.types.grmCase,at.types.mood,at.types.declension,at.types.tense]}static canInflect(e){return!0}static normalizeWord(e){return e&&(e=(e=(e=(e=(e=(e=(e=(e=(e=(e=(e=(e=(e=(e=e.replace(/[\u00c0\u00c1\u00c2\u00c3\u00c4\u0100\u0102]/g,"A")).replace(/[\u00c8\u00c9\u00ca\u00cb\u0112\u0114]/g,"E")).replace(/[\u00cc\u00cd\u00ce\u00cf\u012a\u012c]/g,"I")).replace(/[\u00d2\u00d3\u00d4\u00df\u00d6\u014c\u014e]/g,"O")).replace(/[\u00d9\u00da\u00db\u00dc\u016a\u016c]/g,"U")).replace(/[\u00c6\u01e2]/g,"AE")).replace(/[\u0152]/g,"OE")).replace(/[\u00e0\u00e1\u00e2\u00e3\u00e4\u0101\u0103]/g,"a")).replace(/[\u00e8\u00e9\u00ea\u00eb\u0113\u0115]/g,"e")).replace(/[\u00ec\u00ed\u00ee\u00ef\u012b\u012d\u0129]/g,"i")).replace(/[\u00f2\u00f3\u00f4\u00f5\u00f6\u014d\u014f]/g,"o")).replace(/[\u00f9\u00fa\u00fb\u00fc\u016b\u016d]/g,"u")).replace(/[\u00e6\u01e3]/g,"ae")).replace(/[\u0153]/g,"oe")),e}static alternateWordEncodings(e,t=null,n=null,r=null){return[]}static getPunctuation(){return".,;:!?'\"(){}\\[\\]<>/\\ ‐‑‒–—―‘’“”··\n\r"}static getInflectionConstraints(e){let t={fullFormBased:!1,suffixBased:!1,pronounClassRequired:!1};return e.hasOwnProperty(at.types.part)?e[at.types.part].value===R?t.fullFormBased=!0:t.suffixBased=!0:console.warn("Unable to set grammar: part of speech data is missing or is incorrect",e[at.types.part]),t}}let ze=new Map,Ke=!1;class Xe extends Be{static get languageID(){return c}static get languageCode(){return m}static get languageCodes(){return[m]}static get contextForward(){return 0}static get contextBackward(){return 0}static get direction(){return o}static get baseUnit(){return a}static get featureValues(){return new Map([...Be.featureValues,[at.types.grmClass,[Te,Ve,$e,Ne,Le,Ce,Oe,be,De,Fe]],[at.types.number,[ae,se,oe]],[at.types.grmCase,[X,z,q,W,H]],[at.types.declension,[ie,ue,le]],[at.types.tense,[ye,fe,pe,me,Ee,he,de]],[at.types.voice,[Ae,Ie,we,ve]],[at.types.mood,[Y,ne,ee,Q]],[at.types.dialect,["attic","epic","doric"]]])}static get typeFeatures(){return Ke||this.initTypeFeatures(),ze}static initTypeFeatures(){for(const e of this.featureNames)ze.set(e,this.getFeature(e));Ke=!0}static canInflect(e){return!0}static grammarFeatures(){return[at.types.part,at.types.grmCase,at.types.mood,at.types.declension,at.types.tense,at.types.voice]}static normalizeWord(e){return e?e.normalize("NFC"):e}static alternateWordEncodings(e,t=null,n=null,r=null){let a=Xe.normalizeWord(e).toLocaleLowerCase(),s=a.replace(/[\u{1FB0}\u{1FB1}]/gu,"α").replace(/[\u{1FB8}\u{1FB9}]/gu,"Α").replace(/[\u{1FD0}\u{1FD1}]/gu,"ι").replace(/[\u{1FD8}\u{1FD9}]/gu,"Ι").replace(/[\u{1FE0}\u{1FE1}]/gu,"υ").replace(/[\u{1FE8}\u{1FE9}]/gu,"Υ").replace(/[\u{00AF}\u{0304}\u{0306}]/gu,""),o=a.replace(/\u{0390}/gu,"ί").replace(/\u{03AA}/gu,"Ι").replace(/\u{03AB}/gu,"Υ").replace(/\u{03B0}/gu,"ύ").replace(/\u{03CA}/gu,"ι").replace(/\u{03CB}/gu,"υ").replace(/\u{1FD2}/gu,"ὶ").replace(/\u{1FD3}/gu,"ί").replace(/\u{1FD7}/gu,"ῖ").replace(/\u{1FE2}/gu,"ὺ").replace(/\u{1FE3}/gu,"ύ").replace(/\u{1FE7}/gu,"ῦ").replace(/\u{1FC1}/gu,"῀").replace(/\u{1FED}/gu,"`").replace(/\u{1FEE}/gu,"´").replace(/[\u{00A8}\u{0308}]/gu,"");return"strippedDiaeresis"===r?[o]:[s]}static getPunctuation(){return".,;:!?'\"(){}\\[\\]<>/\\ ‐‑‒–—―‘’“”··\n\r"}static getInflectionConstraints(e){let t={fullFormBased:!1,suffixBased:!1,pronounClassRequired:!1};return e.hasOwnProperty(at.types.part)?e[at.types.part].value===R?t.fullFormBased=!0:t.suffixBased=!0:console.warn("Unable to set grammar: part of speech data is missing or is incorrect",e[at.types.part]),t.pronounClassRequired=nt.compareLanguages(Xe.languageID,e.languageID)&&e.hasOwnProperty(at.types.part)&&e[at.types.part].value===R,t}static getPronounClasses(e,t,n=!0){let r=new Set,a=e.filter(e=>{let r=!1;return e.value&&(r=n?Xe.normalizeWord(e.value)===Xe.normalizeWord(t):e.value===t),r});for(const e of a)if(e.features.hasOwnProperty(at.types.grmClass))for(const t of e.features[at.types.grmClass].values)r.add(t);if(r.size>0)return new at(at.types.grmClass,Array.from(r),Xe.languageID)}}let He=new Map,Je=!1;class Qe extends Be{static get languageID(){return g}static get languageCode(){return E}static get languageCodes(){return[E,y]}static get contextForward(){return 0}static get contextBackward(){return 0}static get direction(){return i}static get baseUnit(){return a}static get typeFeatures(){return Je||this.initTypeFeatures(),He}static initTypeFeatures(){for(const e of this.featureNames)He.set(e,this.getFeature(e));Je=!0}static canInflect(e){return!1}static alternateWordEncodings(e,t=null,n=null,r=null){let a=e.replace(/[\u{064B}\u{064C}\u{064D}\u{0640}]/gu,""),s=a.replace(/[\u{0622}\u{0623}\u{0625}]/gu,"ا"),o=s.replace(/[\u{064E}\u{064F}\u{0650}\u{0670}\u{0671}]/gu,""),i=o.replace(/\u{0651}/gu,""),u=i.replace(/\u{0652}/gu,""),l=u.replace(/\u{0627}/gu,""),c=new Map([["tanwin",a],["hamza",s],["harakat",o],["shadda",i],["sukun",u],["alef",l]]);return null!==r&&c.has(r)?[c.get(r)]:Array.from(c.values())}static getPunctuation(){return".,;:!?'\"(){}\\[\\]<>/\\ ‐‑‒–—―‘’“”··\n\r"}}let Ye=new Map,Ze=!1;class et extends Be{static get languageID(){return d}static get languageCode(){return A}static get languageCodes(){return[A,I,v,w]}static get contextForward(){return 0}static get contextBackward(){return 0}static get direction(){return i}static get baseUnit(){return a}static get typeFeatures(){return Ze||this.initTypeFeatures(),Ye}static initTypeFeatures(){for(const e of this.featureNames)Ye.set(e,this.getFeature(e));Ze=!0}static canInflect(e){return!1}static alternateWordEncodings(e,t=null,n=null,r=null){return[]}static getPunctuation(){return".,;:!?'\"(){}\\[\\]<>/\\ ‐‑‒–—―‘’“”··\n\r"}}const tt=new Map([[f,qe],[h,qe],[m,Xe],[E,Qe],[y,Qe],[A,et]]);class nt{static supportsLanguage(e){return e="symbol"==typeof e?nt.getLanguageCodeFromId(e):e,tt.has(e)}static getLanguageModel(e){let t=nt.getLanguageCodeFromId(e);return tt.has(t)?tt.get(t):Be}static getLanguageForCode(e=null){let t=tt.get(e);return t?new t:new Be}static getLanguageIdFromCode(e){for(const t of tt.values())if(t.hasCode(e))return t.languageID;return u}static getLanguageCodeFromId(e){for(const t of tt.values())if(t.languageID===e)return t.languageCode;return p}static getLanguageAttrs(e){return"symbol"==typeof e?{languageID:e,languageCode:nt.getLanguageCodeFromId(e)}:{languageID:nt.getLanguageIdFromCode(e),languageCode:e}}static compareLanguages(e,t){return(e="symbol"==typeof e?nt.getLanguageCodeFromId(e):e)===(t="symbol"==typeof t?nt.getLanguageCodeFromId(t):t)}}const rt={en:{feminine:{full:"feminine",abbr:"f"},masculine:{full:"masculine",abbr:"m"},neuter:{full:"neuter",abbr:"n"}}};class at{constructor(e,t,n,r=1,a=[]){if(!at.isAllowedType(e))throw new Error('Features of "'+e+'" type are not supported.');if(!t)throw new Error("Feature should have a non-empty value(s).");if(!n)throw new Error("No language ID is provided");this.type=e,this.languageID=n,this.sortOrder=r,this.allowedValues=a,this._data=at.dataValuesFromInput(t),this.sort()}static dataValuesFromInput(e){let t;return(t=Array.isArray(e)?Array.isArray(e[0])?e:e.map((e,t)=>[e,t+1]):[[e,this.defaultSortOrder]]).map(e=>({value:e[0],sortOrder:Number.parseInt(e[1])}))}static newFromFtr(e){}static get types(){return{word:"word",fullForm:"full form",hdwd:"headword",part:"part of speech",number:"number",case:"case",grmCase:"case",declension:"declension",gender:"gender",type:"type",class:"class",grmClass:"class",conjugation:"conjugation",comparison:"comparison",tense:"tense",voice:"voice",mood:"mood",person:"person",frequency:"frequency",meaning:"meaning",source:"source",footnote:"footnote",dialect:"dialect",note:"note",pronunciation:"pronunciation",age:"age",area:"area",geo:"geo",kind:"kind",derivtype:"derivtype",stemtype:"stemtype",morph:"morph",var:"var"}}static isAllowedType(e){return Object.values(this.types).includes(`${e}`)}static get defaultSortOrder(){return 1}static get joinSeparator(){return" "}static get defaultImporterName(){return"default"}get allowsUnrestrictedValues(){return 0===this.allowedValues.length}sort(){this._data.sort((e,t)=>e.sortOrder!==t.sortOrder?e.sortOrder-t.sortOrder:e.value.localeCompare(t.value))}get items(){return this._data}get value(){return this.values.join(this.constructor.joinSeparator)}get values(){return this._data.map(e=>e.value)}getValue(e){return this._data.find(t=>t.value===e)}get valQty(){return this._data.length}get isEmpty(){return 0===this.valQty}get isSingle(){return 1===this.valQty}get isMultiple(){return this.valQty>1}toString(){return this.value}hasValue(e){return this.values.includes(e)}hasValues(e){let t=!0;for(let n of e)t=t&&this.hasValue(n);return t}hasSomeValues(e){let t=!1;for(let n of e)t=t||this.hasValue(n);return t}get valuesUnrestricted(){return 0===this.allowedValues.length}isEqual(e){return this.type===e.type&&nt.compareLanguages(this.languageID,e.languageID)&&this.value===e.value}addValue(e,t=this.constructor.defaultSortOrder){return this.hasValue(e)?console.warn(`Value "${e} already exists. If you want to change it, use "getValue" to access it directly.`):(this._data.push({value:e,sortOrder:t}),this.sort()),this}addValues(e){let t=this.constructor.dataValuesFromInput(e),n=t.map(e=>e.value);return this.hasValue(n)?console.warn(`One or several values from "${n} already exist. If you want to change it, use "getValue" to access a value directly.`):(this._data=this._data.concat(t),this.sort()),this}removeValue(e){console.warn("This feature is not implemented yet")}createFeature(e,t=this.constructor.defaultSortOrder){return new at(this.type,[[e,t]],this.languageID,this.sortOrder,this.allowedValues)}createFeatures(e){return new at(this.type,e,this.languageID,this.sortOrder,this.allowedValues)}getCopy(){let e=this._data.map(e=>[e.value,e.sortOrder]);return new at(this.type,e,this.languageID,this.sortOrder,this.allowedValues.slice())}toLocaleStringAbbr(e="en"){return this.values.map(t=>rt[e][t].abbr)}addImporter(e=new Me,t=this.constructor.defaultImporterName){return this.importers||(this.importers=new Map),this.importers.set(t,e),e}getImporter(e=this.constructor.defaultImporterName){if(!this.importers||!this.importers.has(e))throw new Error(`Importer "${e}" does not exist`);return this.importers.get(e)}addFromImporter(e,t=this.constructor.defaultImporterName){if(!this.importers||!this.importers.has(t))throw new Error(`Importer "${t}" does not exist`);const n=this.importers.get(t);return e=this.constructor.dataValuesFromInput(e),this._data.push(...e.map(e=>({value:n.get(e.value),sortOrder:e.sortOrder}))),this.sort(),this}createFromImporter(e,t=this.constructor.defaultImporterName){if(!this.importers||!this.importers.has(t))throw new Error(`Importer "${t}" does not exist`);const n=this.importers.get(t);Array.isArray(e)||(e=[e]);let r=e.map(e=>n.get(e));return r=r.reduce((e,t)=>e.concat(t),[]),new at(this.type,r,this.languageID,this.sortOrder,this.allowedValues)}}class st{constructor(e,t,n,r=1){if(!st.types.isAllowed(t))throw new Error('Features of "'+t+'" type are not supported.');if(!e)throw new Error("Feature should have a non-empty value.");if(!t)throw new Error("Feature should have a non-empty type.");if(!n)throw new Error("Feature constructor requires a language");this.value=e,this.type=t,this.languageID=void 0,this.languageCode=void 0,({languageID:this.languageID,languageCode:this.languageCode}=nt.getLanguageAttrs(n)),this.sortOrder=r}get language(){return console.warn('Please use a "languageID" instead of a "language"'),this.languageCode}isEqual(e){if(Array.isArray(e.value)){if(!Array.isArray(this.value)||this.value.length!==e.value.length)return!1;let t=this.type===e.type&&nt.compareLanguages(this.languageID,e.languageID);return t=t&&this.value.every(function(t,n){return t===e.value[n]})}return nt.compareLanguages(this.languageID,e.languageID)&&this.type===e.type&&this.value===e.value}isSubsetof(e){Array.isArray(e)||(e=[e]);let t=e[0].languageID,n=e[0].type,r=e.map(e=>e.value);return!(!nt.compareLanguages(this.languageID,t)||this.type!==n||!r.includes(this.value))}hasValue(e){return Array.isArray(this.value)?this.value.includes(e):this.value===e}toString(){return Array.isArray(this.value)?this.value.join(","):this.value}toLocaleStringAbbr(e="en"){return Array.isArray(this.value)?this.value.map(t=>this.toLocaleStringAbbr(t,e)):rt[e][this.value].abbr}static toFeature(e){if(Array.isArray(e)){if(!(e[0]instanceof at)){const t=e[0].type,n=e[0].languageID,r=e.map(e=>e.value);return new at(t,r,n)}}else if(!(e instanceof at))return new at(e.type,e.value,e.languageID);return e}}st.types={word:"word",part:"part of speech",number:"number",case:"case",grmCase:"case",declension:"declension",gender:"gender",type:"type",class:"class",grmClass:"class",conjugation:"conjugation",comparison:"comparison",tense:"tense",voice:"voice",mood:"mood",person:"person",frequency:"frequency",meaning:"meaning",source:"source",footnote:"footnote",dialect:"dialect",note:"note",pronunciation:"pronunciation",age:"age",area:"area",geo:"geo",kind:"kind",derivtype:"derivtype",stemtype:"stemtype",morph:"morph",var:"var",isAllowed(e){let t=`${e}`;return Object.values(this).includes(t)}};class ot{constructor(e,t,n=[],r={}){if(!e)throw new Error("Word should not be empty.");if(!t)throw new Error("Language should not be empty.");this.languageID=void 0,this.languageCode=void 0,({languageID:this.languageID,languageCode:this.languageCode}=nt.getLanguageAttrs(t)),this.word=e,this.principalParts=n,this.features={}}get language(){return console.warn('Please use "languageID" instead of "language"'),this.languageCode}static readObject(e){return new ot(e.word,e.language,e.principalParts,e.pronunciation)}set feature(e){if(console.warn('Please use "addFeature" instead'),!e)throw new Error("feature data cannot be empty.");Array.isArray(e)||(e=[e]);let t=e[0].type;this.features[t]=[];for(let n of e){if(!(n instanceof at))throw new Error("feature data must be a Feature object.");if(!nt.compareLanguages(n.languageID,this.languageID))throw new Error('Language "'+n.languageID.toString()+'" of a feature does not match a language "'+this.languageID.toString()+'" of a Lemma object.');this.features[t].push(n)}}addFeature(e){if(!e)throw new Error("feature data cannot be empty.");if(!(e instanceof at))throw new Error("feature data must be a Feature object.");if(!nt.compareLanguages(e.languageID,this.languageID))throw new Error('Language "'+e.languageID.toString()+'" of a feature does not match a language "'+this.languageID.toString()+'" of a Lemma object.');this.features[e.type]=e}addFeatures(e){if(!Array.isArray(e))throw new Error("Features must be in an array");for(let t of e)this.addFeature(t)}get key(){return[this.word,nt.getLanguageCodeFromId(this.languageID),...Object.values(this.features)].join("-")}}class it{constructor(e,t,n=null,r=null,a=null){if(!e)throw new Error("Stem should not be empty.");if(!t)throw new Error("Language should not be empty.");if(!nt.supportsLanguage(t))throw new Error(`language ${t} not supported.`);this.stem=e,this.languageID=void 0,this.languageCode=void 0,({languageID:this.languageID,languageCode:this.languageCode}=nt.getLanguageAttrs(t)),this.model=nt.getLanguageModel(this.languageID),this.constraints={fullFormBased:!1,suffixBased:!1,obligatoryMatches:[],optionalMatches:[]},this.suffix=n,this.prefix=r,this.example=a}get form(){let e=this.prefix?this.prefix:"";return e+=this.stem,e=this.suffix?e+this.suffix:e}get language(){return console.warn('Please use a "languageID" instead of a "language"'),this.languageCode}setConstraints(){if(this.model.hasOwnProperty("getInflectionConstraints")){let e=this.model.getInflectionConstraints(this);this.constraints=Object.assign(this.constraints,e)}}compareWithWord(e,t=!0){const n=nt.getLanguageModel(this.languageID),r=this.constraints.suffixBased?this.suffix:this.form;return t?n.normalizeWord(r)===n.normalizeWord(e):r===e}static readObject(e){let t=new it(e.stem,e.languageCode,e.suffix,e.prefix,e.example);return t.languageID=nt.getLanguageIdFromCode(t.languageCode),t}set feature(e){if(console.warn('Please use "addFeature" instead.'),!e)throw new Error("Inflection feature data cannot be empty.");Array.isArray(e)||(e=[e]);let t=e[0].type;this[t]=[];for(let n of e){if(!(n instanceof at))throw new Error("Inflection feature data must be a Feature object.");if(!nt.compareLanguages(n.languageID,this.languageID))throw new Error(`Language "${n.languageID.toString()}" of a feature does not match \n          a language "${this.languageID.toString()}" of an Inflection object.`);this[t].push(n)}}addFeature(e){if(!e)throw new Error("feature data cannot be empty.");if(!(e instanceof at))throw new Error("feature data must be a Feature object.");if(!nt.compareLanguages(e.languageID,this.languageID))throw new Error('Language "'+e.languageID.toString()+'" of a feature does not match a language "'+this.languageID.toString()+'" of a Lemma object.');this[e.type]=e}addFeatures(e){if(!Array.isArray(e))throw new Error("Features must be in an array");for(let t of e)this.addFeature(t)}hasFeatureValue(e,t){return!!this.hasOwnProperty(e)&&this[e].values.includes(t)}}class ut{constructor(e,t,n=null){if(!e)throw new Error("Lemma should not be empty.");if(!(e instanceof ot))throw new Error("Lemma should be of Lemma object type.");if(!t)throw new Error("Inflections data should not be empty.");if(!Array.isArray(t))throw new Error("Inflection data should be provided in an array.");for(let e of t)if(!(e instanceof it))throw new Error("All inflection data should be of Inflection object type.");this.lemma=e,this.inflections=t,this.meaning=n||new Ue(this.lemma.word,this.lemma.languageID)}isPopulated(){return Object.entries(this.lemma.features).length>0||!this.meaning.isEmpty()||this.inflections.length>0}getGroupedInflections(){return nt.getLanguageModel(this.lemma.languageID).groupInflectionsForDisplay(this.inflections)}static readObject(e){let t=ot.readObject(e.lemma),n=[];for(let t of e.inflections)n.push(it.readObject(t));let r=new ut(t,n);return r.meaning=Ue.readObject(e.meaning),r}static getSortByTwoLemmaFeatures(e,t){return(n,r)=>n.lemma.features[e]&&r.lemma.features[e]?n.lemma.features[e].sortOrder<r.lemma.features[e].sortOrder?1:n.lemma.features[e].sortOrder>r.lemma.features[e].sortOrder?-1:n.lemma.features[t]&&r.lemma.features[t]?n.lemma.features[t].sortOrder<r.lemma.features[t].sortOrder?1:n.lemma.features[t].sortOrder>r.lemma.features[t].sortOrder?-1:n.lemma.features[t]&&!r.lemma.features[t]?-1:!n.lemma.features[t]&&r.lemma.features[t]?1:0:void 0:n.lemma.features[e]&&!r.lemma.features[e]?-1:!n.lemma.features[e]&&r.lemma.features[e]?1:0}}class lt{constructor(e,t){if(!e)throw new Error("Lexemes data should not be empty.");if(!Array.isArray(e))throw new Error("Lexeme data should be provided in an array.");for(let t of e)if(!(t instanceof ut))throw new Error("All lexeme data should be of Lexeme object type.");this.lexemes=e,this.targetWord=t}static readObject(e){let t=[];if(e.lexemes)for(let n of e.lexemes)t.push(ut.readObject(n));let n=new lt(t);return e.targetWord&&(n.targetWord=e.targetWord),n}get language(){return console.warn("Please use languageID instead"),nt.getLanguageCodeFromId(this.languageID)}get languageID(){if(this.lexemes&&this.lexemes[0]&&this.lexemes[0].lemma&&this.lexemes[0].lemma.languageID)return this.lexemes[0].lemma.languageID;throw new Error("Homonym has not been initialized properly. Unable to obtain language ID information.")}get inflections(){let e=[];for(const t of this.lexemes)e=e.concat(t.inflections);return e}}class ct{constructor(e="",t="",n=new Map([["default",t]])){this.uri=e,this.rights=n,this.rights.has("default")||this.rights.set("default",t)}toString(){return this.rights.get("default")}toLocaleString(e){return this.rights.get(e)||this.rights.get("default")}static getProxy(e=null,t={}){return new Proxy(t,{get:function(t,n){return"provider"===n?e:t[n]}})}}var gt=class{constructor(e,t){this.model=e,this.engine=t;for(let e of Object.keys(this.model.features))this.addFeature(e);this.parseLemma=function(e){return new ot(e,this.model.languageID)},this.parseProperty=function(e,t){let n=[];return n="decl"===e?t.split("&").map(e=>e.trim()):"comp"===e&&"positive"===t?[]:[t]},this.reportLexeme=function(e){return e.lemma.features[at.types.part]}}addFeature(e){this[e]={};let t=this.model;return this[e].add=function(e,t){return this[e]=t,this},this[e].get=function(n,r=1,a=!1){let s=[];if(this.importer.has(n)){let a=this.importer.get(n);s=Array.isArray(a)?t.typeFeature(e).createFeatures(a,r):t.typeFeature(e).createFeature(a,r)}else if(t.typeFeature(e).hasValue(n)||t.typeFeature(e).valuesUnrestricted)s=t.typeFeature(e).createFeature(n,r);else{let o=`Unknown value "${n}" of feature "${e}" for ${t.languageCode} (allowed = ${a})`;if(!a)throw new Error(o);console.log(o),s=t.typeFeature(e).createFeature(n,r)}return s},this[e].getMultiple=function(n,r=!1){let a=[];for(const s of n)if(this.importer.has(s.providerValue)){let e=this.importer.get(s.providerValue);a=Array.isArray(e)?e:[e,s.sortOrder]}else if(t.typeFeature(e).hasValue(s.providerValue)||t.typeFeature(e).valuesUnrestricted)a.push([s.providerValue,s.sortOrder]);else{let n=`Unknown value "${s.providerValue}" of feature "${e}" for ${t.languageCode} (allowed = ${r})`;if(!r)throw new Error(n);console.log(n),a.push([s.providerValue,s.sortOrder])}return t.typeFeature(e).createFeatures(a)},this[e].importer=new Me,this[e]}setLemmaParser(e){this.parseLemma=e}setPropertyParser(e){this.parseProperty=e}setLexemeFilter(e){this.reportLexeme=e}mapFeature(e,t,n,r,a){let s=[],o=t[n];if(o)if(Array.isArray(o))for(let e of o)s.push(...this.parseProperty(n,e.$));else s=this.parseProperty(n,o.$);if(s.length>0){s=s.map(e=>({providerValue:e,sortOrder:o.order?o.order:1}));let t=this[at.types[r]].getMultiple(s,a);e.addFeature(t)}}};let dt=new gt(qe,"whitakerLat");dt.addFeature(at.types.gender).importer.map("common",[[Re.GEND_MASCULINE,1],[Re.GEND_FEMININE,2]]).map("all",[[Re.GEND_MASCULINE,1],[Re.GEND_FEMININE,2],[Re.GEND_NEUTER,3]]),dt.addFeature(at.types.tense).importer.map("future_perfect",Re.TENSE_FUTURE_PERFECT),dt.setLemmaParser(function(e){let t,n,r=[],a=e.split(", ");for(let[e,t]of a.entries()){let a=t.split(" ")[0];0===e&&(n=a),r.push(a)}return n&&(t=new ot(n,this.model.languageCode,r)),t});var pt=dt;let ht=new gt(Xe,"morpheusgrc");ht.addFeature(at.types.gender).importer.map("masculine feminine",[[Re.GEND_MASCULINE,1],[Re.GEND_FEMININE,2]]),ht.addFeature(at.types.declension).importer.map("1st & 2nd",[[Re.ORD_1ST,1],[Re.ORD_2ND,2]]);var ft=ht;let mt=new gt(Qe,"aramorph");mt.addFeature(at.types.part).importer.map("proper noun",Re.POFS_NOUN);var Et=mt;let yt=new gt(et,"hazm");yt.addFeature(at.types.part).importer.map("proper noun",Re.POFS_NOUN),yt.setLexemeFilter(function(e){return Boolean(e.lemma.word)});var It=yt,At=n(4),wt=n.n(At),vt=n(3),_t=n.n(vt),St=n(2),Ct=n.n(St),Dt=n(1),Ot=n.n(Dt);var Tt=class{constructor(){this._words={cupidinibus:wt.a,mare:_t.a,cepit:Ct.a,"φιλόσοφος":Ot.a}}get(e){if(this._words.hasOwnProperty(e))return this._words[e];throw new Error(`Word "${e}" does not exist in test data`)}},Ft=n(0),Lt=n.n(Ft);var Vt=class extends r{constructor(e={}){super();try{this.config=JSON.parse(Lt.a)}catch(e){this.config=Object.assign({},Lt.a)}Object.assign(this.config,e),this.engineMap=new Map([pt,ft,Et,It].map(e=>[e.engine,e]))}getEngineLanguageMap(e){return this.config.engine[e]?this.engineMap.get(this.config.engine[e][0]):null}prepareRequestUrl(e,t){let n=this.getEngineLanguageMap(e);if(n){let r=n.engine;return this.config.url.replace("r_WORD",t).replace("r_ENGINE",r).replace("r_LANG",e)}return null}fetchTestData(e,t){return new Promise((e,n)=>{try{let r=(new Tt).get(t);e(JSON.parse(r))}catch(e){n(e)}})}transform(e,t){let n=[],r=e.RDF.Annotation.Body;Array.isArray(r)||(r=r?[r]:[]);let a=e.RDF.Annotation.creator.Agent.about,s="";e.RDF.Annotation.rights&&(s=e.RDF.Annotation.rights.$);let o=new ct(a,s);for(let e of r){let r,a=e.rest.entry.infl;a?Array.isArray(a)||(a=[a]):a=[];let s=[["pofs","part"],["case","grmCase"],["gend","gender"],["decl","declension"],["conj","conjugation"],["area","area"],["age","age"],["geo","geo"],["freq","frequency"],["note","note"],["pron","pronunciation"],["src","source"],["kind","kind"]];e.rest.entry.dict?Array.isArray(e.rest.entry.dict)?r=e.rest.entry.dict:(!e.rest.entry.dict.hdwd&&a[0].term&&(e.rest.entry.dict.hdwd={},e.rest.entry.dict.hdwd.lang=a[0].term.lang,e.rest.entry.dict.hdwd.$=a[0].term.stem.$+a[0].term.suff.$),r=[e.rest.entry.dict]):a.length>0&&a[0].term&&(r=[a[0].term]);let i=r[0].hdwd?r[0].hdwd.lang:r[0].lang,u=this.getEngineLanguageMap(i),l=[],c=[];for(let t of r.entries()){let n,a=[],g=t[0],d=t[1];if(d.hdwd&&(n=d.hdwd.$),!n||!i)continue;let p=u.parseLemma(n,i);l.push(p);for(let e of s)u.mapFeature(p,d,...e,this.config.allowUnknownValues);let h=e.rest.entry.mean;if(Array.isArray(h)||(h=[h]),h=h.filter(e=>e),r.length>1){if(h&&h[g]){let e=h[g],t=e.lang?e.lang:"eng";a.push(ct.getProxy(o,new Pe(e.$,t,"text/plain",l[g].word)))}}else{let e=h.map(e=>{let t=e.lang?e.lang:"eng";return ct.getProxy(o,new Pe(e.$,t,"text/plain",p.word))});a.push(...e)}let f=new ut(p,[]);f.meaning.appendShortDefs(a),c.push(ct.getProxy(o,f))}if(0===l.length)continue;let g=[];for(let e of a){let n=new it(e.term.stem.$,u.model.languageID);t&&n.addFeature(new at(at.types.fullForm,t,u.model.languageID)),e.term.suff&&(n.suffix=e.term.suff.$),e.xmpl&&(n.example=e.xmpl.$),u.mapFeature(n,e,"pofs","part",this.config.allowUnknownValues),u.mapFeature(n,e,"case","grmCase",this.config.allowUnknownValues),u.mapFeature(n,e,"decl","declension",this.config.allowUnknownValues),u.mapFeature(n,e,"num","number",this.config.allowUnknownValues),u.mapFeature(n,e,"gend","gender",this.config.allowUnknownValues),u.mapFeature(n,e,"conj","conjugation",this.config.allowUnknownValues),u.mapFeature(n,e,"tense","tense",this.config.allowUnknownValues),u.mapFeature(n,e,"voice","voice",this.config.allowUnknownValues),u.mapFeature(n,e,"mood","mood",this.config.allowUnknownValues),u.mapFeature(n,e,"pers","person",this.config.allowUnknownValues),u.mapFeature(n,e,"comp","comparison",this.config.allowUnknownValues),e.stemtype&&u.mapFeature(n,e,"stemtype","stemtype",this.config.allowUnknownValues),e.derivtype&&u.mapFeature(n,e,"derivtype","derivtype",this.config.allowUnknownValues),e.dial&&u.mapFeature(n,e,"dial","dialect",this.config.allowUnknownValues),e.morph&&u.mapFeature(n,e,"morph","morph",this.config.allowUnknownValues),(n[at.types.grmCase]||n[at.types.tense]||n[at.types.mood]||n[at.types.voice]||n[at.types.person]||n[at.types.comparison]||n[at.types.stemtype]||n[at.types.derivtype]||n[at.types.dialect]||n[at.types.morph]||n[at.types.example])&&g.push(n);for(let t of l)t.features[at.types.part]||u.mapFeature(t,e,"pofs","part",this.config.allowUnknownValues),t.features[at.types.declension]||t.features[at.types.part]&&!t.features[at.types.part].isEqual(n[at.types.part])||u.mapFeature(t,e,"decl","declension",this.config.allowUnknownValues),t.features[at.types.conjugation]||t.features[at.types.part]&&!t.features[at.types.part].isEqual(n[at.types.part])||u.mapFeature(t,e,"conj","conjugation",this.config.allowUnknownValues)}for(let e of c)u.reportLexeme(e)&&(e.inflections=g,n.push(e))}return n.length>0?new lt(n,t):void 0}async getHomonym(e,t){let n=await this.fetch(e,t);if(n)return this.transform(n,t)}};n.d(t,"BaseAdapter",function(){return r}),n.d(t,"AlpheiosTuftsAdapter",function(){return Vt})}])});